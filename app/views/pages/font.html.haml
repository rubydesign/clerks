%h1 Fonts

%p
  A little exercise in generating numbers, copied from three example.
  Only the bevel and text can be changed (by just typing).
  Then download and do the rest in slicer.

= javascript_include_tag "three_all"
:javascript
  let font_asset = "#{asset_path('oleo.json')}" ;

#info
  type to enter new text, drag to spin the text
  %br/
  %button#bevel add bevel
  %button#exportBinary export binary


:javascript

  THREE.Cache.enabled = true;

  let container;

  let camera, cameraTarget, scene, renderer;

  let group, textMesh1, textGeo, materials;

  let firstLetter = true;

  let text = "0123456789",    font = undefined;

  let  bevelThickness = 2, bevelSize = 1.5 ;
  const height = 20,
    size = 70,
    hover = 30,
    curveSegments = 4;

  let targetRotation = 0;
  let targetRotationOnPointerDown = 0;

  let pointerX = 0;
  let pointerXOnPointerDown = 0;

  let windowHalfX = window.innerWidth / 2;

  let fontIndex = 1;

  init();
  animate();

  function init() {

    container = document.createElement( 'div' );
    document.body.appendChild( container );

    // CAMERA

    camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
    camera.position.set( 0, 400, 700 );

    cameraTarget = new THREE.Vector3( 0, 150, 0 );

    // SCENE

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x000000 );
    scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

    // LIGHTS

    const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
    dirLight.position.set( 0, 0, 1 ).normalize();
    scene.add( dirLight );

    const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
    pointLight.position.set( 0, 100, 90 );
    scene.add( pointLight );

    // Get text from hash

    pointLight.color.setHSL( Math.random(), 1, 0.5 );

    materials = [
      new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
      new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
    ];

    group = new THREE.Group();
    group.position.y = 100;

    scene.add( group );

    loadFont();

    const plane = new THREE.Mesh(
      new THREE.PlaneBufferGeometry( 10000, 10000 ),
      new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
    );
    plane.position.y = 100;
    plane.rotation.x = - Math.PI / 2;
    scene.add( plane );

    // RENDERER

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    container.style.touchAction = 'none';
    container.addEventListener( 'pointerdown', onPointerDown, false );

    document.addEventListener( 'keypress', onDocumentKeyPress, false );
    document.addEventListener( 'keydown', onDocumentKeyDown, false );

    pointLight.color.setHSL( Math.random(), 1, 0.5 );

    document.getElementById( "bevel" ).addEventListener( 'click', function () {

      bevelThickness = bevelThickness + 0.5;
      bevelSize = bevelSize + 0.5;
      refreshText();

    }, false );

    window.addEventListener( 'resize', onWindowResize, false );

  }

  function onWindowResize() {

    windowHalfX = window.innerWidth / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function onDocumentKeyDown( event ) {

    if ( firstLetter ) {

      firstLetter = false;
      text = "";

    }

    const keyCode = event.keyCode;

    // backspace

    if ( keyCode == 8 ) {

      event.preventDefault();

      text = text.substring( 0, text.length - 1 );
      refreshText();

      return false;

    }

  }

  function onDocumentKeyPress( event ) {

    const keyCode = event.which;

    // backspace

    if ( keyCode == 8 ) {

      event.preventDefault();

    } else {

      const ch = String.fromCharCode( keyCode );
      text += ch;

      refreshText();

    }

  }

  function loadFont() {

    const loader = new THREE.FontLoader();
    loader.load( font_asset, function ( response ) {

      font = response;

      refreshText();

    } );

  }

  function createText() {

    textGeo = new THREE.TextGeometry( text, {

      font: font,

      size: size,
      height: height,
      curveSegments: curveSegments,

      bevelThickness: bevelThickness,
      bevelSize: bevelSize,
      bevelEnabled: true

    } );

    textGeo.computeBoundingBox();
    textGeo.computeVertexNormals();

    const triangle = new THREE.Triangle();

    const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

    textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );

    textMesh1 = new THREE.Mesh( textGeo, materials );

    textMesh1.position.x = centerOffset;
    textMesh1.position.y = hover;
    textMesh1.position.z = 0;

    textMesh1.rotation.x = 0;
    textMesh1.rotation.y = Math.PI * 2;

    group.add( textMesh1 );

  }

  function refreshText() {

    group.remove( textMesh1 );

    if ( ! text ) return;

    createText();

  }

  function onPointerDown( event ) {

    if ( event.isPrimary === false ) return;

    pointerXOnPointerDown = event.clientX - windowHalfX;
    targetRotationOnPointerDown = targetRotation;

    document.addEventListener( 'pointermove', onPointerMove, false );
    document.addEventListener( 'pointerup', onPointerUp, false );

  }

  function onPointerMove( event ) {

    if ( event.isPrimary === false ) return;

    pointerX = event.clientX - windowHalfX;

    targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

  }

  function onPointerUp() {

    if ( event.isPrimary === false ) return;

    document.removeEventListener( 'pointermove', onPointerMove );
    document.removeEventListener( 'pointerup', onPointerUp );

  }

  //

  function animate() {

    requestAnimationFrame( animate );

    render();

  }

  function render() {

    group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;

    camera.lookAt( cameraTarget );

    renderer.clear();
    renderer.render( scene, camera );

  }

  exporter = new STLExporter();
  const buttonExportBinary = document.getElementById( 'exportBinary' );
  buttonExportBinary.addEventListener( 'click', exportBinary );

  function exportBinary() {
    const result = exporter.parse( textMesh1, { binary: true } );
    saveArrayBuffer( result, 'numbers.stl' );
  }

  const link = document.createElement( 'a' );
  link.style.display = 'none';
  document.body.appendChild( link );

  function save( blob, filename ) {

    link.href = URL.createObjectURL( blob );
    link.download = filename;
    link.click();

  }

  function saveArrayBuffer( buffer, filename ) {

    save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );

  }
