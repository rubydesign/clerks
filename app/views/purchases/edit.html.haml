.row.purchase-app
  .col-md-6.purchases
    %h2= in_place @purchase , :name
  .col-md-2.pill{ "v-bind:class" => "{active_pill: tab == 1}"}
    %h4
      %a{"@click" => "tab = 1"}= t(:basket)
  .col-md-2.pill{"v-bind:class" => "{active_pill: tab == 2}"}
    %h4
      %a{"@click" => "tab = 2"}= t(:products)
      \&nbsp;
      %a.right{"@click" => "products_to_basket"}
        =image_tag "plus.png" , width: "20px"
  .col-md-2.pill{"v-bind:class" => "{active_pill: tab == 3}"}
    %h4
      %a{"@click" => "tab = 3"}=t(:orders)
      \&nbsp;
      %a.right{"@click" => "orders_to_basket"}
        =image_tag "plus.png" , width: "20px"

  .col-md-12.tab{"v-bind:class" => "{active_tab: tab == 1}"}
    =render "basket"
  .col-md-12.tab{"v-bind:class" => "{active_tab: tab == 2}"}
    =render "products"
  .col-md-12.tab{"v-bind:class" => "{active_tab: tab == 3}"}
    =render "orders"
.row
  .col-md-2
    = link_to( t(:back) , purchase_path(@purchase) , class: "btn btn-info")
  .col-md-2
    = link_to t(:edit) + " " + t(:basket), edit_basket_path(@purchase.basket), :class => "btn btn-info edit_basket" unless @purchase.basket.locked?

:ruby2js
  class App < Vue
    options el: '.purchase-app'
    def initialize
      @purchase = #{@purchase.to_json(include: :supplier)}
      @basket = #{ render( partial: "baskets/basket.json") }
      @products = #{ render( partial: "purchases/products.json") }
      @tab = 1
      @nameQuery = ""
      @categoryQuery = ""
      @columns = {inventory: "#{t(:inventory)}" , stock_level: "#{t(:stock_level).split.first}" ,
          stock_diff: "diff", pack_unit: "#{t(:pack_unit)}", cost: "#{t(:cost)}" ,ordered: "#{t(:order)}" }
      @sortOrders = {inventory: 1, cost: 1 , stock_level: 1 , stock_diff: 1,
                   pack_unit: 1 , ordered: 1}
      @sortKey = ""
      @changed = false
    end
    def filteredBasket
      return @basket.items.slice().sort do |a, b|
        aa = a["position"]
        bb = b["position"]
        return (aa === bb ? 0 : aa > bb ? 1 : -1) * 1
      end
    end
    def filteredProducts
      dat = @products
      if(@nameQuery)
        dat = data.filter do |prod|
          return prod.name.toLowerCase().indexOf(@nameQuery.toLowerCase()) > -1
        end
      end
      if(@categoryQuery)
        query = @categoryQuery;
        dat = dat.filter do |prod|
          return prod.category.toLowerCase().indexOf(query.toLowerCase()) > -1
        end
      end
      order = @sortOrders[@sortKey] || 1
      if(@sortKey)
        dat = dat.slice().sort do |a, b|
          aa = parseFloat(a[@sortKey])
          bb = parseFloat(b[@sortKey])
          return (aa === bb ? 0 : aa > bb ? 1 : -1) * order
        end
      end
      return dat
    end
    def capitalize(string)
     return string[0].toUpperCase() + string.substring(1)
    end
    def itemProp(item, index , prop)
      return { value: item[prop] ,
              name: 'basket[items_attributes][' + index +'][' + prop + ']',
              id: 'basket_items_attributes_' + index + '_' + prop
             }
    end
    def sortBy(key)
      @sortKey = key;
      @sortOrders[key] = @sortOrders[key] * -1;
    end
    def submit_basket(event)
      event.preventDefault()
      jQuery.post( '/baskets/' + @basket.id , jQuery(".edit_basket").serializeArray() , null , "json").
        done() { |saved_basket| @basket = saved_basket ; @changed = false }.
        fail() { console.log( "error" ) }
    end
    def orders_to_basket(_)
      @products.each { |product| self.to_basket(product) if(product.ordered) }
    end
    def products_to_basket(_)
      @products.each() {|product| self.to_basket(product) }
    end
    def to_basket(product)
      amount = product.ordered + product.stock_level - product.inventory
      return if(amount < 0)
      if(product.pack_unit > 1)
        amount = Math.ceil(amount / product.pack_unit ) * product.pack_unit
      end
      item = this.in_basket(product)
      if(item)
        @changed = true if( item.quantity != amount)
        item.quantity = amount
      else
        this.basket.items.push({ name: product.name ,
                             quantity: amount,
                                scode: product.scode,
                                price: product.cost,
                           product_id: product.id,
                            pack_unit: product.pack_unit,
                             position: product.position});
        @changed = true
      end
    end
    def in_basket(product)
      0.upto(this.basket.items.length - 1) do |i|
        return this.basket.items[i] if(this.basket.items[i].product_id == product.id)
      end
      return false;
    end
    def total_price(_)
      sum = 0
      @basket.items.each { |item| sum += item.price * item.quantity }
      return sum
    end
    def total_amount(_)
      sum = 0
      @basket.items.each { |item| sum += item.quantity }
      return sum
    end
  end
